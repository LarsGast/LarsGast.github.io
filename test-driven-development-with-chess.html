<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8" />
    <title>LarsGast - Test Driven Development with Chess</title>
</head>
<body>
    <header>
        <h1>Just Another Title</h1>
    </header>
    <main>
        <article>
            <h2>Test Driven Development with Chess</h2>
            <section>
                <h3>Introduction</h3>
                <p>
                    Sometimes when I'm bored, I start a coding project of something that I enjoy doing. I've written projects about solving a sudoku, or finding the best strategy at beat-the-house poker. Chess has been an interest of mine for a while now, so it was only a matter of time before I started writing my very own chess application.
                </p>
                <p>
                    Over the course of my development journey, I have tried a total of 4 times to create an application in which I can play chess. I would start writing the application, but I would run into complex issues regarding piece movement or code management every time. Every now and then, I would get a new idea on how to solve the previous issues. At such a moment, I had forgotten how the code in my old project worked and I would start a new one.
                </p>
                <p>
                    Eventually, I settled on the <abbr title="Test Driven Development">TDD</abbr> approach. This made me to reconsider what is really required in order to play a game of chess, while at the same time forcing me to build a comprehensive test suite for my application. The application is written in <abbr title="C Sharp">C#</abbr> and hosted on <a href="https://github.com/LarsGast/Chess-Logic" title="Go to the repository">GitHub</a>.
                </p>
                <p>
                    In this article, I will walk through the steps I took to write the logic for a chess application using <abbr title="Test Driven Development">TDD</abbr>. I will highlight the hurdles I had to overcome and show the different decisions I had to make in order to make the application as robust and complete as I could.
                </p>
            </section>

            <section>
                <h3>Test Driven Development (<abbr title="Test Driven Development">TDD</abbr>)</h3>
                <p>
                    The code that you write can fail. In fact, come code that you right <em>will</em> fail, whether you accept it or not. In order to make our code fail less, we can create tests, which automatically run your code and look for bugs. If no bugs are found, great! Your code works. If the tests do find a bug, also great! Now you know where the bug comes from, and you can fix it before you push your code to production. Writing proper tests can help you ensure that your code does what it's supposed to do, while not having to plough through all the different pieces of functionality in your project yourself.
                </p>
                <section>
                    <h4>Unit tests</h4>
                    <p>
                        So what are these tests, and what do they look like? There are different types of tests, such as end to end tests and unit tests. In this article, I will focus mainly on unit tests, as that is what I used when writing my chess application.
                    </p>
                    <p>
                        A unit test is basically a function or method in your code that checks if other methods are working. It does so by calling those methods and testing whether the desired result is returned. Say you have the following method in <abbr title="C Sharp">C#</abbr>:
                        <pre><code>public static int add(int firstNumber, int secondNumber)
{
    return firstNumber + secondNumber;
}</code></pre>
                        This returns the sum of the two input numbers. If you want to test whether this method works, you could write the following test using NUnit:
                        <pre><code>[Test]
public static void shouldAdd()
{
    var firstNumber = 1;
    var secondNumber = 2;

    var result = add(firstNumber, secondNumber);

    Assert.That(result, Is.EqualTo(3));
}</code></pre>
                        This test method add 1 and 2 together, and expects that the answer is 3. If the test passes, which is to say the result from adding 1 and 2 together is equal to 3, then we know the method works. If the test fails, we know there is a bug in our code. Now of course, we haven't tested all the possibilities yet. What if the test fails if we add 100 and 200 together? Should we write a unit test for that scenario too? No, often times it is enough to have a single unit test, as long as the method you call in the test is generic enough. The test we've written now just tells us that a simple addition of 2 numbers doesn't go wrong. We can assume from this that other simple additions also pass this test since the method we call is so simple.
                    </p>
                </section>
            </section>

            <section>
                <h3>Creating the tests</h3>
                <p>

                </p>
            </section>

            <section>
                <h3>ChessPiece class</h3>
                <p>

                </p>
                <section>
                    <h4>Creating each piece</h4>
                    <p>

                    </p>
                </section>
            </section>
            
            <section>
                <h3>ChessBoard class</h3>
                <p>
                    
                </p>
                <section>
                    <h4>Setting up the board</h4>
                    <p>
                        
                    </p>
                </section>
                
                <section>
                    <h4>Making a move</h4>
                    <p>
                        
                    </p>
                    <section>
                        <h5>Legal moves</h5>
                        <p>

                        </p>
                    </section>
                    <section>
                        <h5>Illegal moves</h5>
                        <p>
                            
                        </p>
                    </section>
                    <section>
                        <h5>Special moves</h5>
                        <p>
                            
                        </p>
                        <section>
                            <h6>Initial pawn move</h6>
                            <p>
                                
                            </p>
                        </section>
                        <section>
                            <h6>Promotion</h6>
                            <p>
                                
                            </p>
                        </section>
                        <section>
                            <h6>En passant</h6>
                            <p>
                                
                            </p>
                        </section>
                        <section>
                            <h6>Castling</h6>
                            <p>
                                
                            </p>
                        </section>
                    </section>
                </section>
            </section>
        </article>
    </main>
    <nav>
        <a href="./">Go back</a>
    </nav>
</body>
</html>